# Redux-vs-MobX-vs-Effector
## Мне необходимо ответить на вопрос: **какой из фреймворков для организации состояния в React нам подходит лучше всего?**

## Запуск demo
`npm install`

`npm run start`

Откройте [http://localhost:3000](http://localhost:3000) в браузере. На странице будет несколько ссылок: **Redux, Mobx, Effector** _(сейчас его страница не реализована)_.

На каждой странице находятся кнопки для 10 тестов. Вверху страницы расположен переключатель параметра N. Его изменение перезагружает страницу.

_Тест 1 запустится автоматически (это обусловлено его природой)._

## Запуск demo в production режиме
`npm install`

`npm run build`

`npm run start:builded`

Откройте [http://localhost:5000](http://localhost:5000) в браузере. На странице будет несколько ссылок: **Redux, Mobx, Effector** _(сейчас его страница не реализована)_.

На каждой странице находятся кнопки для 10 тестов. Вверху страницы расположен переключатель параметра N. Его изменение перезагружает страницу.

_Тест 1 запустится автоматически (это обусловлено его природой)._

### Критерии сравнения:

 - производительность (скорость чтения/записи на объектах с большим количеством свойств (до 1000) и большой вложенностью объектов (до 1000)). В том числе понять, по какой функции деградирует производительности при увеличении сложности объекта
 - объем трафика
 - многословность синтаксиса для решения типовых задач
 - удобство подключения, удобство работы
 - размер сообщества/тренд роста популярности

### Подготовка данных

Приложение для каждого фреймворка состояний построено на основе некого `store`. Во время создания `store` происходят следующие активности:
 - определяется `N` - количество дочерних `micro store`, которые содержат в себе данные в виде `flat object` или `array`. Соответствует числу `Фибоначчи от 13 до 10946` (_последнее все же 10000, поскольку вкладка умирает примерно на 10200_).
 - генерируется `N slice`, описывающих данные в виде `flat object` и `N flatSlice`, описывающих данные в виде `array`. Общее количество свойств в `flat object` или в `array` не больше `144`.
 - все сгенерированные `micro store` комбинируются в 1 корневой `store`, который передается в `<Provider>` каждого конкретного фреймворка состояний.

### Тесты производительности
Результатом каждого теста является **время в миллисекундах**, требуемое для его выполнения.
Для каждого `slice` реализованы `action`: `check` (_меняет 1 свойство_), `generateNewData` (_меняет все свойства_), `unCheck` (_удаляет 1 свойство_) и `clear` (_очищает все свойства_).
Для каждого `flatSlice` реализованы `action`: `addNewItem` (_добавляет 1 элемент_), `generateNewData` (_меняет все элементы_), `deleteItem` (_удаляет 1 элемент_) и `clear` (_очищает массив_).
`action`, которые нацелены на добавление/изменение/удаление свойств запускаются в двух отдельных режимах: синхронно для всех `micro store` и асинхронно через `setTimeout(0)` для каждого отдельного `micro store`.

По типам операций тесты можно сгруппировать:
- Чтение. `Test 1,  Test 2`
- Запись в объект. `Test 3,  Test 4`
- Запись в массив. `Test 5, Test 6`
- Удаление из объекта. `Test 7,  Test 8`
- Удаление из массива. `Test 9, Test 10`
- Асинхронная запись в объект. `Test 11, Test 12`
- Асинхронная запись в массив. `Test 13, Test 14`
- Асинхронное удаление из объекта. `Test 15, Test 16`
- Асинхронное удаление из массива. `Test 17, Test 18`

Список тестов:

- `Test 1` - Вытаскиваем из `store` `N slice` и `N flatSlice`.
- `Test 2` - Читаем свойство `level` в каждом `slice`.
- `Test 3` - Вызываем `action` `check` для каждого `slice`.
- `Test 4` - Вызываем `action` `generateNewData` для каждого `slice`.
- `Test 5` - Вызываем `action` `addNewItem` для каждого `flatSlice`.
- `Test 6` - Вызываем `action` `generateNewData` для каждого `flatSlice`.
- `Test 7` - Вызываем `action` `unCheck` для каждого `slice`.
- `Test 8` - Вызываем `action` `clear` для каждого `slice`.
- `Test 9` - Вызываем `action` `deleteItem` для каждого `flatSlice`.
- `Test 10` - Вызываем `action` `clear` для каждого `flatSlice`.
- `Test 11` - **Асинхронно** вызываем `action` `check` для каждого `slice`.
- `Test 12` - **Асинхронно** вызываем `action` `generateNewData` для каждого `slice`.
- `Test 13` - **Асинхронно** вызываем `action` `addNewItem` для каждого `flatSlice`.
- `Test 14` - **Асинхронно** вызываем `action` `generateNewData` для каждого `flatSlice`.
- `Test 15` - **Асинхронно** вызываем `action` `unCheck` для каждого `slice`.
- `Test 16` - **Асинхронно** вызываем `action` `clear` для каждого `slice`.
- `Test 17` - **Асинхронно** вызываем `action` `deleteItem` для каждого `flatSlice`.
- `Test 18` - **Асинхронно** вызываем `action` `clear` для каждого `flatSlice`.
