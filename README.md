# Redux-vs-MobX-vs-Effector
## Мне необходимо ответить на вопрос: **какой из фреймворков для организации состояния в React нам подходит лучше всего?**

### Критерии сравнения:

 - производительность (скорость чтения/записи на объектах с большим количеством свойств (до 1000) и большой вложенностью объектов (до 1000)). В том числе понять, по какой функции деградирует производительности при увеличении сложности объекта
 - объем трафика
 - многословность синтаксиса для решения типовых задач
 - удобство подключения, удобство работы
 - размер сообщества/тренд роста популярности

### Для достижения цели необходимо

- подготовить данные в нужном формате для следующих порядков глубины/ширины: `13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584`
- ответить на вопрос об объеме трафика
- собрать информацию о размере сообщества и данные о трендах
- реализовать механизм на всех трех демках, который изменит данные и замерит скорость реакции фреймворка.
- одной из операций должно быть удаление большого количества элементов поштучно через минимальную асинхронную задержку для каждого удаления.
- собрать информацию о долги операциях внутри фреймворка в момент его работы с большим объемом данных.
- выделить список типовых задач.
- сделать субъективные выводы о многословности синтаксиса для решения типовых задач.
- сделать субъективные выводы об удобстве подключения и работы. Собрать мнение сообщества, если это возможно.

### Правила формирования объекта данных для тестирования

Описание сущностей:

 - **Свойство** - атомарная единица данных. Ключ свойства описывается по шаблону.
 - **Примитивное свойство** - свойство, значение по ключу которого описывается значением данных `Boolean`, `Number` или `String`. Ключ свойства описывается по шаболну `S_XXX`, где `XXX` - порядковый номер, выданный при генерации свойства.
 - **Ссылка** - свойство, значение по ключу которого описывается как слой.
 - **Корень** - объект, который является первым в цепочке сгенерированного дерева данных.
 - **Слой** - объект, на который ссылается корень или другой слой.
 - **Упорядоченный слой** - слой, значения ключей которого вложены в `Array`. Значение `level` лежит в `0` индексе.
 - **Хвост** - слой, который содержит в себе только примитивные значения в свойствах.
 - **Упорядоченный хвост** - слой, значения ключей которого вложены в `Array`. Значение `level` лежит в `0` индексе. Значение `tail` лежит в индексе `1` и содержит строку `"tail"`.
 
Описание параметров:

 - **N** - Общее количество объектов при генерации начальных данных, определяется параметром. Соответствует одному из чисел ряда Фибоначчи от 10 до 1000.
 - **Пропорция** - соотношение максимального числа примитивных свойств к максимальному числу ссылок внутри одного слоя. Зависит от **N**. Для `N = 34` пропорция будет `21 к 13`.
 - **Nj** - (N junior) младшее число пропорции. Для `N = 34` это будет `13`. Поскольку, именно оно влияет на глубину объекта, диапазон N выделен до `2584`. Только при этом значении `Nj будет близко к 1000`, что соответствует условиям задачи.
 - **Ne** - (N elder) старшее число пропорции. Для `N = 34` это будет `21`.

Поскольку, расти необходимо как вглубь, так и в ширину, предлагается сформировать ряд правил для каждого "слоя" вложенности, а также для связи слоёв.

 - Первым генерируется цепочка из `Nj` вложенных слоев.
 - В случайное место сгенерированной цепочки помещается новый слой. Новый слой тоже может быть выбран для генерации следующего слоя.
 - Генерация продолжается до тех пор, пока общее количество слоев в дереве не будет равно `N`

Правила генерации простых свойств:

 - В слое минимум 1 свойство (помимо level и/или count и/или total)
 - Общее количество простых свойств в слое (помимо level и/или tail) не больше, чем `Nj`
 - Ключ первого простого свойства S_0. Далее - по-возрастанию счетчика: S_1, ...S_42 и т.д.
 - Генерация может прекратиться, если на очередном шаге функция `random от Nj` вернет `0`

Правила генерации ссылок:

 - В слое может не быть ссылок, тогда этот слой становится хвостом.
 - Общее количество ссылок в слое не больше, чем `Nj`
 - Ключ первой ссылки L_0. Далее - по-возрастанию счетчика: L_1, ...L_42 и т.д.

### Манипуляции с данными во время тестирования

Нас интересует следующий ряд операций, который потенциально может привести к фризам:

 - Первое применение данных
 - Изменение примитивных свойств одного и того же слоя Nj раз подряд
 - Изменение примитивных свойств для Nj разных слоев
 - Добавление Nj новых свойств в один слой, если это возможно
 - Добавление нового слоя в Nj новых слоев, если это возможно
 - Удаление N разных хвостов поштучно
 - Удаление Nj разных слоев не раньше level 2 поштучно

Все операции совершаются несколько раз. Каждый такт работает через setTimeout(..., 0)
